package com.AnimeFire

import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.app
import org.jsoup.nodes.Element

// Funções de utilidade para extração de episódios
object AnimeFireUtils {
    
    // Extrai número do episódio de um texto
    fun extractEpisodeNumber(text: String): Int? {
        val patterns = listOf(
            Regex("Epis[oó]dio\\s*(\\d+)"),
            Regex("Ep\\.?\\s*(\\d+)"),
            Regex("(\\d{1,3})\\s*-"),
            Regex("#(\\d+)"),
            Regex("\\b(\\d{1,4})\\b")
        )
        
        for (pattern in patterns) {
            val match = pattern.find(text)
            if (match != null) {
                return match.groupValues[1].toIntOrNull()
            }
        }
        return null
    }
    
    // Determina se é dublado ou legendado
    fun determineAudioType(element: Element): String {
        val text = element.text().lowercase()
        return when {
            text.contains("dublado") -> "Dub"
            text.contains("legendado") -> "Leg"
            else -> "Sub" // Padrão legendado
        }
    }
    
    // Busca último episódio de um anime
    suspend fun getLastEpisodeInfo(url: String): Pair<Int?, String?> {
        return try {
            val document = app.get(url).document
            
            // Buscar todos os elementos de episódio
            val episodeElements = document.select("a.lEp.epT, a.lEp, .divListaEps a, [href*='/video/'], [href*='/episodio/']")
            
            if (episodeElements.isEmpty()) {
                return Pair(null, null)
            }
            
            var maxEpisode = 0
            var audioType: String? = null
            
            episodeElements.forEach { element ->
                val text = element.text().trim()
                val episodeNum = extractEpisodeNumber(text) ?: 0
                
                if (episodeNum > maxEpisode) {
                    maxEpisode = episodeNum
                    audioType = when {
                        text.contains("dublado", ignoreCase = true) -> "Dub"
                        text.contains("legendado", ignoreCase = true) -> "Leg"
                        else -> null
                    }
                }
            }
            
            Pair(if (maxEpisode > 0) maxEpisode else null, audioType)
        } catch (e: Exception) {
            Pair(null, null)
        }
    }
    
    // Extrai status do anime
    fun extractStatus(document: org.jsoup.nodes.Document): String {
        val statusElement = document.selectFirst("div.animeInfo:contains(Status:) span.spanAnimeInfo")
        return statusElement?.text()?.trim() ?: "Desconhecido"
    }
    
    // Extrai tipo de áudio disponível
    fun extractAudioTypes(document: org.jsoup.nodes.Document): Pair<Boolean, Boolean> {
        val audioElement = document.selectFirst("div.animeInfo:contains(Audio:) span.spanAnimeInfo")
        val audioText = audioElement?.text()?.trim() ?: "Legendado"
        
        val hasSub = audioText.contains("Legendado", ignoreCase = true)
        val hasDub = audioText.contains("Dublado", ignoreCase = true)
        
        return Pair(hasSub, hasDub)
    }
}
